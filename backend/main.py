from gevent import monkey
monkey.patch_all()

from flask import Flask, request, session
from flask_socketio import SocketIO, emit, join_room, leave_room
from flask_cors import CORS
import numpy as np
import spacy
from scipy.spatial import distance
import random
import os
from uuid import uuid4
import time
import math

nlp = spacy.load('en_core_web_lg')
# Loaded from word_ids file as a cache, but generated by the following:
# word_ids = [word_id for word_id in nlp.vocab.vectors.keys() if (lambda word: word.isalpha() and word.islower())(nlp.vocab[word_id].text)]
with open('word_ids', 'r') as f:
    word_ids = [int(line) for line in f]
word_vecs = [nlp.vocab.vectors[x] for x in word_ids]
word_vecs = np.array(word_vecs)

app = Flask(__name__)
app.config['SESSION_TYPE'] = 'filesystem'
app.secret_key = os.environ.get('SECRET_KEY', 'dev')
CORS(app)
socketio = SocketIO(app, logger=True, cors_allowed_origins="*")

# the metric used to norm word vectors
METRIC = 'cosine' 

def vec_dist(w1, w2):
    return distance.cdist(np.array([w1]), np.array([w2]), metric=METRIC)[0,0]

# turns word into vector
def wv(w):
    ret = nlp(w)[0].vector
    if not ret.any():
        # all zeros, not a word
        raise ValueError(f"word {w} does not exist")
    return ret

def closest_n_words(inp_word, n):
    closest_indexes = np.argpartition(distance.cdist(np.array([inp_word]), word_vecs, metric=METRIC), n)[0,:n]
    result = []
    for closest_index in closest_indexes:
        word_id = word_ids[closest_index]
        output_word = nlp.vocab[word_id].text
        result.append((output_word, vec_dist(word_vecs[closest_index], inp_word)))
    result.sort(key=lambda k: k[1])
    return result


# Six digit random code.
def random_code() -> int:
    return random.randint(100_000, 999_999)

# Random word from the NLP dataset.
def random_word() -> str:
    word_id = random.choice(word_ids)
    return nlp.vocab[word_id].text

def dist_to_score(distance: float) -> int:
    return int(math.ceil(np.exp(-distance) * 100))

def calc_score(word: str, guess: (str, str, str)) -> int:
    dist = vec_dist(wv(word), wv(guess[0]) - wv(guess[1]) + wv(guess[2]))
    return dist_to_score(dist)

class Room:
    code: int
    player_ids: list[str]
    playing: list[str]
    ready: list[str]
    roundNumber: int
    word: str
    endTime: int
    submissions: dict[str, (str, str, str)]
    roundScores: dict[str, int] = {}

    def __init__(self, creator_id: str):
        self.code = random_code()
        self.player_ids = [creator_id]
        self.playing = []
        self.ready = []
        self.roundNumber = 0

    def join_room(self, player_id: str):
        self.player_ids.append(player_id)

    def is_playing(self) -> bool:
        return len(self.playing) > 0

    def sid_is_playing(self, sid: str) -> bool:
        return sid in self.playing

    def get_info(self) -> dict[str, any]:
        return {
            "currentlyPlaying": self.is_playing(),
            "players": idsToNames(self.player_ids),
            "ready": idsToNames(self.ready),
            "playing": idsToNames(self.playing)
        }

    def set_ready(self, sid: str, ready: bool):
        already_present = sid in self.ready
        if ready:
            if not already_present:
                self.ready.append(sid)
        elif not ready:
            if already_present:
                self.ready.remove(sid)

    def round_should_start(self):
        return len(self.ready) > len(self.playing)/2 and not self.is_playing()

    def start_round(self) -> dict[str, any]: 
        self.roundNumber += 1
        if self.roundNumber == 1:
            self.roundScores = { k:0 for k in self.playing }
        self.word = random_word()
        ROUND_TIME = 30 # seconds
        self.endTime = int(time.time()) + ROUND_TIME
        self.submissions = {}
        return {
            "roundNumber": self.roundNumber,
            "word": self.word,
            "timeLeft": ROUND_TIME
        }

    def end_round(self) -> dict[str, any]:
        # calculate score
        for sid in self.playing:
            if sid in self.submissions:
                self.roundScores[sid] += calc_score(self.word, self.submissions[sid])
        return {
            "roundNumber": self.roundNumber,
            "guesses": { sids_to_usernames[sid]:guess for sid,guess in self.submissions.items() },
            "playerScores": { sids_to_usernames[sid]:score for sid,score in self.roundScores.items() }
        }
    
    def delete_player(self, sid: str):
        def removeIfExists(arr: list[str], sid: str):
            if sid in arr:
                arr.remove(sid)
        removeIfExists(self.player_ids, sid)
        removeIfExists(self.playing, sid)
        removeIfExists(self.ready, sid)



sid_data: dict[str, dict[str, any]] = {}
sids_to_usernames: dict[str, str] = {}
def idsToNames(sid_arr):
    return [sids_to_usernames[sid] for sid in sid_arr]
rooms: dict[int, Room] = {}
# session_ids: dict[str, str] = {}

def create_room(username):
    room = Room(username)
    rooms[room.code] = room
    return room.code

def create_sid():
    sid = str(uuid4())
    session['sid'] = sid
    sid_data[sid] = { "sid": sid }

def get_sid():
    return session['sid']

def validate_username(data) -> bool:
    return (data is not None) and ('username' in data) and isinstance(data['username'], str) and len(data['username']) > 0

@app.post('/api/create-room')
def api_create_room():
    data = request.json
    if not validate_username(data):
        return { 'error': 'bad body' }, 400
    create_sid()
    udata = sid_data[get_sid()]
    udata['username'] = data['username']
    sids_to_usernames[get_sid()] = data['username']
    code = create_room(get_sid())
    udata['code'] = code
    print('room', code, 'has been created by', get_sid())
    return { 'code': code, 'uid': get_sid() }

@app.post('/api/join-room')
def api_join_room():
    data = request.json
    if not validate_username(data) or 'code' not in data or not isinstance(data['code'], int):
        return { 'error': 'bad body' }, 400
    code = data['code']
    if code not in rooms:
        return { 'error': 'Invalid room code' }, 400
    room_before_players = idsToNames(rooms[code].player_ids)
    if data['username'] in room_before_players:
        return { 'error': "Username is already present in that room" }, 400
    create_sid()
    udata = sid_data[get_sid()]
    udata['username'] = data['username']
    sids_to_usernames[get_sid()] = data['username']
    rooms[code].join_room(get_sid())
    udata['code'] = code
    # TODO what if room is currently playing?
    print('room', code, 'has been joined by', get_sid())
    return { 'code': code, 'uid': get_sid() }

socket_to_sid: dict[str, str] = {}

def socket_get_udata():
    return sid_data[socket_to_sid[request.sid]]

def socket_error(errmsg):
    emit('error', { "error": errmsg })

def socket_validate() -> bool:
    return request.sid in socket_to_sid

def room_broadcast(name, data):
    udata = socket_get_udata()
    emit(name, data, to=udata['code'])

@socketio.on('connect')
def socket_connect():
    pass

@socketio.on('identify')
def player_identify(data):
    print('player_identify', data)
    if data is None or 'uid' not in data or not isinstance(data['uid'], str):
        socket_error('Invalid body')
        return
    sid = data['uid']
    if sid not in sid_data:
        socket_error('Invalid UID')
        return
    socket_to_sid[request.sid] = sid
    udata = socket_get_udata()
    join_room(udata['code'])
    room_broadcast('room-info', rooms[udata['code']].get_info())

@socketio.on('status-update')
def player_status_update(data):
    if not socket_validate():
        socket_error('Not authenticated')
        return
    if data is None or 'ready' not in data or not isinstance(data['ready'], bool):
        socket_error('Invalid body')
        return
    udata = socket_get_udata()
    room = rooms[udata['code']]
    room.set_ready(udata['sid'], data['ready'])
    room_broadcast('room-info', room.get_info())
    if room.round_should_start():
        socketio.sleep(5)
        if room.round_should_start(): # someone may have unreadied in the meantime
            # actual round logic, XXX this is probably not the best place to put it
            print('starting game in room', udata['code'])
            room.playing = [x for x in room.player_ids]
            while room.roundNumber < 5:
                room_broadcast('round-start', room.start_round())
                round_time = room.endTime - int(time.time())
                print('round_time =', round_time, '(endTime =', room.endTime, ')')
                while round_time > 0:
                    socketio.sleep(1)
                    round_time -= 1
                    if len(room.submissions) == len(room.playing):
                        # round is done, early exit
                        break
                room_broadcast('round-end', room.end_round())
                socketio.sleep(7)
            socketio.sleep(3)
            room_broadcast('room-info', room.get_info())

@socketio.on('round-submit')
def player_round_submit(data):
    print('submit', data)
    if not socket_validate():
        socket_error('Not authenticated')
        return
    if data is None or 'words' not in data or not isinstance(data['words'], list) or len(data['words']) != 3 or not all(isinstance(word, str) for word in data['words']):
        socket_error('Invalid body')
        return
    udata = socket_get_udata()
    words = data['words']
    room = rooms[udata['code']]
    sid = udata['sid']
    if not room.sid_is_playing(sid):
        socket_error('Round has not started yet')
        return
    if sid in room.submissions:
        socket_error('You have already submitted for this round')
        return
    # filter non-alphabet
    if not all(word.isalpha() for word in words):
        socket_error('Cannot have non-alphabetical words')
        return
    words = [w.lower() for w in words]
    # filter duplicates
    if room.word in words or any(words.count(w) > 1 for w in words):
        socket_error('Cannot duplicate words')
        return
    for word in words:
        try:
            wv(word)
        except ValueError:
            # word doesn't exist
            socket_error(f'{word} is not a word')
            return
    print('valid submission')
    room.submissions[sid] = tuple(words)
    room_broadcast('round-update', { 'username': udata['username'] })

@socketio.on('disconnect')
def socket_disconnect():
    # remove them from room
    if socket_validate():
        udata = socket_get_udata()
        if 'code' in udata:
            room = rooms[udata['code']]
            room.delete_player(udata['sid'])
            print('disconnect', udata['sid'])
            if len(room.player_ids) == 0:
                # no more players, delete the room
                del rooms[udata['code']]
if __name__ == '__main__':
    print('start')
    socketio.run(app, host='0.0.0.0', port=2345)
